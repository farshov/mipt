Пока каждый процесс обращается к памяти только в том виде, в котором сконфигурирован центральный процессор, защита памяти невидима. Когда процесс нарушает правила, ЦП будет генерировать синхронное прерывание, запрашивая у ядра сортировку.

Важное различие между сигналами и прерываниями заключается в том, что для каждого сигнала существует поведение по умолчанию. Если операционная система не может определить обработчики для всех прерываний, это ошибка в ОС, и весь компьютер выйдет из строя, когда процессор попытается вызвать отсутствующий обработчик. Но процессы не обязаны определять обработчики сигналов для всех сигналов. Если ядро ​​генерирует сигнал для процесса, и этот сигнал остался по умолчанию, ядро ​​будет просто идти вперед и делать все, что по умолчанию, и не беспокоить процесс. Большинство поведения по умолчанию для сигналов либо «ничего не делают», либо «завершают этот процесс и, возможно, также создают основной дамп». SIGSEGV является одним из последних.



Итак, чтобы повторить, у нас есть процесс, который нарушил правила защиты памяти. Процессор приостановил процесс и создал синхронное прерывание. Ядро вывело это прерывание и сгенерировало сигнал SIGSEGV для процесса. Предположим, что процесс не настроил обработчик сигналов для SIGSEGV, поэтому ядро ​​выполняет поведение по умолчанию, которое заключается в завершении процесса. Это имеет все те же последствия, что и системный вызов _exit: открытые файлы закрыты, память освобождается и т. Д.

До этого момента ничто не печатало никаких сообщений, которые человек мог видеть, и оболочка (или, в более общем плане, родительский процесс только что завершившегося процесса) не была задействована вообще. SIGSEGV переходит к процессу, который нарушил правила, а не его родитель. Следующий шаг в последовательности, однако, состоит в том, чтобы уведомить родительский процесс о прекращении его дочернего процесса. Это может произойти несколькими различными способами, наиболее простым из которых является то, что родитель уже ждет этого уведомления, используя один из системных вызовов ожидания (wait, waitpid, wait4 и т. Д.). В этом случае ядро ​​просто вызовет возврат системного вызова и предоставит родительскому процессу номер кода, называемый статусом выхода.7 Статус выхода информирует родителя о том, почему дочерний процесс был прерван; в этом случае он узнает, что ребенок был прерван из-за поведения по умолчанию сигнала SIGSEGV.

Затем родительский процесс может сообщить об этом событию человеку, напечатав сообщение; программы оболочки почти всегда делают это. Ваш crsh не включает в себя код для этого, но это так или иначе, потому что в подпрограмме библиотеки C запускается полнофункциональная оболочка / bin / sh, «под капотом». crsh является дедушкой и бабушкой в ​​этом сценарии; уведомление родительского процесса выставляется командой / bin / sh, которая печатает свое обычное сообщение. Затем / bin / sh сам выходит, поскольку ему больше нечего делать, и реализация системы C библиотеки получает это уведомление о выходе. Вы можете увидеть это уведомление о выходе в своем коде, проверив возвращаемое значение системы; но он не скажет вам, что процесс внука умер на segfault, потому что это было поглощено промежуточным процессом оболочки.
